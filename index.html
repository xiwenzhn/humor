<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Relational Values Diagram</title>
  <style>
    @font-face {
      font-family: 'ABCDiatypeCondensed-Regular-Trial';
      src: url('ABCDiatypeCondensed-Regular-Trial.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }

    html, body { margin: 0; padding: 0; overflow: hidden; font-family: "ABCDiatypeCondensed-Regular-Trial", sans-serif; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script>
    // Category to sub-values mapping
    const categories = {
      Conditional: [
        "Discretion",
        "Privacy",
        "Access and visibilities",
        "Withholding",
        "Susceptible to change",
        "Ambivalence"
      ],
      Periodical: [
        "Introspection",
        "Attentions",
        "Active participation"
      ],
      Incidental: [
        "Instabilities",
        "Chaos",
        "Agitation",
        "Disruptions",
        "Confrontations",
        "Turbulent",
        "Improvisation"
      ],
      Subversive: [
        "Resistance",
        "Friction",
        "Criticality",
        "Candidness"
      ],
      Inherent: [
        "Adaptive",
        "Agile",
        "Intuition",
        "Independence",
        "Ambiguity"
      ],
      Relational: [
        "Dependency",
        "Reciprocity",
        "Intimacy",
        "Vulnerability"
      ],
      Situational: [
        "Liminality",
        "Paradoxes",
        "Observant"
      ]
    };

    let words = [];
    let dots = [];
    let connections = [];
    let expanded = {};

    function setup() {
      createCanvas(windowWidth, windowHeight);
      textFont("Arial Rounded MT Bold", 16);
      noiseDetail(2, 0.5);
      words = Object.keys(categories);
      generateInitialDots();
    }

    function draw() {
      background(255);
      // central title
      noStroke(); fill(0);
      textAlign(CENTER, CENTER);
      textSize(24);
      text("VALUES", width/2, height/2);

      // Update dot positions
      for (let d of dots) {
        let theta = frameCount * 0.005 + d.noise;
        d.x = d.cx + cos(theta) * d.wiggle;
        d.y = d.cy + sin(theta) * d.wiggle;
      }
      // Draw organic connections
      noFill(); stroke(0, 50); strokeWeight(1);
      for (let c of connections) {
        drawOrganicLine(c.a.x, c.a.y, c.b.x, c.b.y);
      }
      // Draw dots and labels
      noStroke(); fill(0);
      textAlign(CENTER, CENTER);
      for (let d of dots) {
        ellipse(d.x, d.y, 10);
        text(d.label, d.x, d.y - 15);
      }
    }

    function mousePressed() {
      for (let d of dots) {
        if (dist(mouseX, mouseY, d.x, d.y) < 10) {
          if (!expanded[d.label]) {
            expanded[d.label] = true;
            expandDot(d);
          }
          break;
        }
      }
    }

    function generateInitialDots() {
      const margin = 100;
      let cx = width / 2;
      let cy = height / 2;
      for (let i = 0; i < words.length; i++) {
        let baseX = random(margin, width - margin);
        let baseY = random(margin, height - margin);
        // ensure dots avoid center title area
        if (dist(baseX, baseY, cx, cy) < 100) {
          baseX += (baseX < cx ? -1 : 1) * 120;
          baseY += (baseY < cy ? -1 : 1) * 120;
        }
        dots.push({ cx: baseX, cy: baseY, x: baseX, y: baseY, wiggle: random(20, 50), noise: random(1000), label: words[i] });
      }
    }

    function expandDot(origin) {
      const group = categories[origin.label] || [];
      let newDots = [];
      for (let lbl of group) {
        let ang = random(TWO_PI);
        // longer branch length
        let distR = random(150, 300);
        let baseX = origin.cx + cos(ang) * distR;
        let baseY = origin.cy + sin(ang) * distR;
        let d = { cx: baseX, cy: baseY, x: baseX, y: baseY, wiggle: random(10, 30), noise: random(1000), label: lbl };
        dots.push(d);
        connections.push({ a: origin, b: d });
        newDots.push(d);
      }
      // Interconnect the new words among themselves
      for (let i = 0; i < newDots.length; i++) {
        for (let j = i + 1; j < newDots.length; j++) {
          connections.push({ a: newDots[i], b: newDots[j] });
        }
      }
    }

    function drawOrganicLine(x1, y1, x2, y2) {
      let segments = 30;
      for (let i = 0; i < segments; i++) {
        let t1 = i / segments;
        let t2 = (i + 1) / segments;
        let sx = lerp(x1, x2, t1);
        let sy = lerp(y1, y2, t1);
        let ex = lerp(x1, x2, t2);
        let ey = lerp(y1, y2, t2);
        let n = noise(i * 0.1, frameCount * 0.005);
        let offset = map(n, 0, 1, -15, 15);
        let ang = atan2(ey - sy, ex - sx) + HALF_PI;
        let ox = cos(ang) * offset;
        let oy = sin(ang) * offset;
        line(sx + ox, sy + oy, ex + ox, ey + oy);
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      dots = [];
      connections = [];
      expanded = {};
      generateInitialDots();
    }
  </script>
</body>
</html>
